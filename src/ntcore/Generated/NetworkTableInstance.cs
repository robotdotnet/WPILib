// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

// THIS FILE WAS AUTO-GENERATED BY ./ntcore/generate_topics.py. DO NOT MODIFY

using System;
using NetworkTables.Natives;

namespace NetworkTables;

/**
 * NetworkTables Instance.
 *
 * <p>Instances are completely independent from each other. Table operations on one instance will
 * not be visible to other instances unless the instances are connected via the network. The main
 * limitation on instances is that you cannot have two servers on the same network port. The main
 * utility of instances is for unit testing, but they can also enable one program to connect to two
 * different NetworkTables networks.
 *
 * <p>The global "default" instance (as returned by {@link #GetDefault()}) is always available, and
 * is intended for the common case when there is only a single NetworkTables instance being used in
 * the program.
 *
 * <p>Additional instances can be created with the {@link #create()} function. A reference must be
 * kept to the NetworkTableInstance returned by this function to keep it from being garbage
 * collected.
 */
public sealed class NetworkTableInstance
{

    public int Handle { get; }

    // /** The default port that network tables operates on for NT3. */
    // public const int kDefaultPort3 = 1735;

    // /** The default port that network tables operates on for NT4. */
    // public const int kDefaultPort4 = 5810;

    // /**
    //  * Construct from native handle.
    //  *
    //  * @param handle Native handle
    //  */
    // private NetworkTableInstance(int handle) {
    //   m_owned = false;
    //   Handle = handle;
    // }

    // /** Destroys the instance (if created by {@link #create()}). */

    // public void Dispose() {
    //   lock(this) {
    //     if (m_owned && Handle != 0) {
    //       m_listeners.close();
    //       m_schemas.forEach((k, v) -> v.close());
    //       NtCore.destroyInstance(Handle);
    //       Handle = 0;
    //     }
    //   }
    // }

    // /**
    //  * Determines if the native handle is valid.
    //  *
    //  * @return True if the native handle is valid, false otherwise.
    //  */
    // public bool IsValid => Handle != 0;

    // /* The default instance. */
    // private static NetworkTableInstance s_defaultInstance;

    // /**
    //  * Get global default instance.
    //  *
    //  * @return Global default instance
    //  */
    // public static NetworkTableInstance GetDefault() {
    //   lock (typeof(NetworkTableInstance)) {
    //     if (s_defaultInstance == null) {
    //       s_defaultInstance = new NetworkTableInstance(NtCore.GetDefaultInstance());
    //     }
    //     return s_defaultInstance;
    //   }
    // }

    // /**
    //  * Create an instance. Note: A reference to the returned instance must be retained to ensure the
    //  * instance is not garbage collected.
    //  *
    //  * @return Newly created instance
    //  */
    // public static NetworkTableInstance create() {
    //   NetworkTableInstance inst = new NetworkTableInstance(NtCore.CreateInstance());
    //   inst.m_owned = true;
    //   return inst;
    // }

    // /**
    //  * Gets the native handle for the instance.
    //  *
    //  * @return Native handle
    //  */
    // public int Handle { Get; }

    // /**
    //  * Get (generic) topic.
    //  *
    //  * @param name topic name
    //  * @return Topic
    //  */
    // public Topic GetTopic(string name) {
    //   Topic topic = m_topics.Get(name);
    //   if (topic == null) {
    //     int handle = NtCore.GetTopic(Handle, name);
    //     topic = new Topic(this, handle);
    //     Topic oldTopic = m_topics.putIfAbsent(name, topic);
    //     if (oldTopic != null) {
    //       topic = oldTopic;
    //     }
    //     // also cache by handle
    //     m_topicsByHandle.putIfAbsent(handle, topic);
    //   }
    //   return topic;
    // }

    // /**
    //  * Get bool topic.
    //  *
    //  * @param name topic name
    //  * @return BooleanTopic
    //  */
    // public BooleanTopic GetBooleanTopic(string name) {
    //   Topic topic = m_topics.Get(name);
    //   if (topic is BooleanTopic typedTopic) {
    //     return typedTopic;
    //   }

    //   int handle;
    //   if (topic == null) {
    //     handle = NtCore.GetTopic(Handle, name);
    //   } else {
    //     handle = topic.GetHandle();
    //   }

    //   BooleanTopic wrapTopic = new BooleanTopic(this, handle);
    //   m_topics.put(name, wrapTopic);

    //   // also cache by handle
    //   m_topicsByHandle.put(handle, wrapTopic);

    //   return wrapTopic;
    // }

    // /**
    //  * Get long topic.
    //  *
    //  * @param name topic name
    //  * @return IntegerTopic
    //  */
    // public IntegerTopic GetIntegerTopic(string name) {
    //   Topic topic = m_topics.Get(name);
    //   if (topic is IntegerTopic typedTopic) {
    //     return typedTopic;
    //   }

    //   int handle;
    //   if (topic == null) {
    //     handle = NtCore.GetTopic(Handle, name);
    //   } else {
    //     handle = topic.GetHandle();
    //   }

    //   IntegerTopic wrapTopic = new IntegerTopic(this, handle);
    //   m_topics.put(name, wrapTopic);

    //   // also cache by handle
    //   m_topicsByHandle.put(handle, wrapTopic);

    //   return wrapTopic;
    // }

    // /**
    //  * Get float topic.
    //  *
    //  * @param name topic name
    //  * @return FloatTopic
    //  */
    // public FloatTopic GetFloatTopic(string name) {
    //   Topic topic = m_topics.Get(name);
    //   if (topic is FloatTopic typedTopic) {
    //     return typedTopic;
    //   }

    //   int handle;
    //   if (topic == null) {
    //     handle = NtCore.GetTopic(Handle, name);
    //   } else {
    //     handle = topic.GetHandle();
    //   }

    //   FloatTopic wrapTopic = new FloatTopic(this, handle);
    //   m_topics.put(name, wrapTopic);

    //   // also cache by handle
    //   m_topicsByHandle.put(handle, wrapTopic);

    //   return wrapTopic;
    // }

    // /**
    //  * Get double topic.
    //  *
    //  * @param name topic name
    //  * @return DoubleTopic
    //  */
    // public DoubleTopic GetDoubleTopic(string name) {
    //   Topic topic = m_topics.Get(name);
    //   if (topic is DoubleTopic typedTopic) {
    //     return typedTopic;
    //   }

    //   int handle;
    //   if (topic == null) {
    //     handle = NtCore.GetTopic(Handle, name);
    //   } else {
    //     handle = topic.GetHandle();
    //   }

    //   DoubleTopic wrapTopic = new DoubleTopic(this, handle);
    //   m_topics.put(name, wrapTopic);

    //   // also cache by handle
    //   m_topicsByHandle.put(handle, wrapTopic);

    //   return wrapTopic;
    // }

    // /**
    //  * Get string topic.
    //  *
    //  * @param name topic name
    //  * @return StringTopic
    //  */
    // public StringTopic GetStringTopic(string name) {
    //   Topic topic = m_topics.Get(name);
    //   if (topic is StringTopic typedTopic) {
    //     return typedTopic;
    //   }

    //   int handle;
    //   if (topic == null) {
    //     handle = NtCore.GetTopic(Handle, name);
    //   } else {
    //     handle = topic.GetHandle();
    //   }

    //   StringTopic wrapTopic = new StringTopic(this, handle);
    //   m_topics.put(name, wrapTopic);

    //   // also cache by handle
    //   m_topicsByHandle.put(handle, wrapTopic);

    //   return wrapTopic;
    // }

    // /**
    //  * Get byte[] topic.
    //  *
    //  * @param name topic name
    //  * @return RawTopic
    //  */
    // public RawTopic GetRawTopic(string name) {
    //   Topic topic = m_topics.Get(name);
    //   if (topic is RawTopic typedTopic) {
    //     return typedTopic;
    //   }

    //   int handle;
    //   if (topic == null) {
    //     handle = NtCore.GetTopic(Handle, name);
    //   } else {
    //     handle = topic.GetHandle();
    //   }

    //   RawTopic wrapTopic = new RawTopic(this, handle);
    //   m_topics.put(name, wrapTopic);

    //   // also cache by handle
    //   m_topicsByHandle.put(handle, wrapTopic);

    //   return wrapTopic;
    // }

    // /**
    //  * Get bool[] topic.
    //  *
    //  * @param name topic name
    //  * @return BooleanArrayTopic
    //  */
    // public BooleanArrayTopic GetBooleanArrayTopic(string name) {
    //   Topic topic = m_topics.Get(name);
    //   if (topic is BooleanArrayTopic typedTopic) {
    //     return typedTopic;
    //   }

    //   int handle;
    //   if (topic == null) {
    //     handle = NtCore.GetTopic(Handle, name);
    //   } else {
    //     handle = topic.GetHandle();
    //   }

    //   BooleanArrayTopic wrapTopic = new BooleanArrayTopic(this, handle);
    //   m_topics.put(name, wrapTopic);

    //   // also cache by handle
    //   m_topicsByHandle.put(handle, wrapTopic);

    //   return wrapTopic;
    // }

    // /**
    //  * Get long[] topic.
    //  *
    //  * @param name topic name
    //  * @return IntegerArrayTopic
    //  */
    // public IntegerArrayTopic GetIntegerArrayTopic(string name) {
    //   Topic topic = m_topics.Get(name);
    //   if (topic is IntegerArrayTopic typedTopic) {
    //     return typedTopic;
    //   }

    //   int handle;
    //   if (topic == null) {
    //     handle = NtCore.GetTopic(Handle, name);
    //   } else {
    //     handle = topic.GetHandle();
    //   }

    //   IntegerArrayTopic wrapTopic = new IntegerArrayTopic(this, handle);
    //   m_topics.put(name, wrapTopic);

    //   // also cache by handle
    //   m_topicsByHandle.put(handle, wrapTopic);

    //   return wrapTopic;
    // }

    // /**
    //  * Get float[] topic.
    //  *
    //  * @param name topic name
    //  * @return FloatArrayTopic
    //  */
    // public FloatArrayTopic GetFloatArrayTopic(string name) {
    //   Topic topic = m_topics.Get(name);
    //   if (topic is FloatArrayTopic typedTopic) {
    //     return typedTopic;
    //   }

    //   int handle;
    //   if (topic == null) {
    //     handle = NtCore.GetTopic(Handle, name);
    //   } else {
    //     handle = topic.GetHandle();
    //   }

    //   FloatArrayTopic wrapTopic = new FloatArrayTopic(this, handle);
    //   m_topics.put(name, wrapTopic);

    //   // also cache by handle
    //   m_topicsByHandle.put(handle, wrapTopic);

    //   return wrapTopic;
    // }

    // /**
    //  * Get double[] topic.
    //  *
    //  * @param name topic name
    //  * @return DoubleArrayTopic
    //  */
    // public DoubleArrayTopic GetDoubleArrayTopic(string name) {
    //   Topic topic = m_topics.Get(name);
    //   if (topic is DoubleArrayTopic typedTopic) {
    //     return typedTopic;
    //   }

    //   int handle;
    //   if (topic == null) {
    //     handle = NtCore.GetTopic(Handle, name);
    //   } else {
    //     handle = topic.GetHandle();
    //   }

    //   DoubleArrayTopic wrapTopic = new DoubleArrayTopic(this, handle);
    //   m_topics.put(name, wrapTopic);

    //   // also cache by handle
    //   m_topicsByHandle.put(handle, wrapTopic);

    //   return wrapTopic;
    // }

    // /**
    //  * Get string[] topic.
    //  *
    //  * @param name topic name
    //  * @return StringArrayTopic
    //  */
    // public StringArrayTopic GetStringArrayTopic(string name) {
    //   Topic topic = m_topics.Get(name);
    //   if (topic is StringArrayTopic typedTopic) {
    //     return typedTopic;
    //   }

    //   int handle;
    //   if (topic == null) {
    //     handle = NtCore.GetTopic(Handle, name);
    //   } else {
    //     handle = topic.GetHandle();
    //   }

    //   StringArrayTopic wrapTopic = new StringArrayTopic(this, handle);
    //   m_topics.put(name, wrapTopic);

    //   // also cache by handle
    //   m_topicsByHandle.put(handle, wrapTopic);

    //   return wrapTopic;
    // }


    // // TODO add back in struct and protobuf topics

    // private Topic[] TopicHandlesToTopics(int[] handles) {
    //   Topic[] topics = new Topic[handles.length];
    //   for (int i = 0; i < handles.length; i++) {
    //     topics[i] = GetCachedTopic(handles[i]);
    //   }
    //   return topics;
    // }

    // /**
    //  * Get all published topics.
    //  *
    //  * @return Array of topics.
    //  */
    // public Topic[] GetTopics() {
    //   return TopicHandlesToTopics(NtCore.GetTopics(Handle, "", 0));
    // }

    // /**
    //  * Get published topics starting with the given prefix. The results are optionally filtered by
    //  * string prefix to only return a subset of all topics.
    //  *
    //  * @param prefix topic name required prefix; only topics whose name starts with this string are
    //  *     returned
    //  * @return Array of topic information.
    //  */
    // public Topic[] GetTopics(String prefix) {
    //   return topicHandlesToTopics(NtCore.GetTopics(Handle, prefix, 0));
    // }

    // /**
    //  * Get published topics starting with the given prefix. The results are optionally filtered by
    //  * string prefix and data type to only return a subset of all topics.
    //  *
    //  * @param prefix topic name required prefix; only topics whose name starts with this string are
    //  *     returned
    //  * @param types bitmask of data types; 0 is treated as a "don't care"
    //  * @return Array of topic information.
    //  */
    // public Topic[] GetTopics(String prefix, int types) {
    //   return topicHandlesToTopics(NtCore.GetTopics(Handle, prefix, types));
    // }

    // /**
    //  * Get published topics starting with the given prefix. The results are optionally filtered by
    //  * string prefix and data type to only return a subset of all topics.
    //  *
    //  * @param prefix topic name required prefix; only topics whose name starts with this string are
    //  *     returned
    //  * @param types array of data type strings
    //  * @return Array of topic information.
    //  */
    // public Topic[] GetTopics(String prefix, String[] types) {
    //   return topicHandlesToTopics(NtCore.GetTopicsStr(Handle, prefix, types));
    // }

    // /**
    //  * Get information about all topics.
    //  *
    //  * @return Array of topic information.
    //  */
    // public TopicInfo[] GetTopicInfo() {
    //   return NtCore.GetTopicInfos(this, Handle, "", 0);
    // }

    // /**
    //  * Get information about topics starting with the given prefix. The results are optionally
    //  * filtered by string prefix to only return a subset of all topics.
    //  *
    //  * @param prefix topic name required prefix; only topics whose name starts with this string are
    //  *     returned
    //  * @return Array of topic information.
    //  */
    // public TopicInfo[] GetTopicInfo(String prefix) {
    //   return NtCore.GetTopicInfos(this, Handle, prefix, 0);
    // }

    // /**
    //  * Get information about topics starting with the given prefix. The results are optionally
    //  * filtered by string prefix and data type to only return a subset of all topics.
    //  *
    //  * @param prefix topic name required prefix; only topics whose name starts with this string are
    //  *     returned
    //  * @param types bitmask of data types; 0 is treated as a "don't care"
    //  * @return Array of topic information.
    //  */
    // public TopicInfo[] GetTopicInfo(String prefix, int types) {
    //   return NtCore.GetTopicInfos(this, Handle, prefix, types);
    // }

    // /**
    //  * Get information about topics starting with the given prefix. The results are optionally
    //  * filtered by string prefix and data type to only return a subset of all topics.
    //  *
    //  * @param prefix topic name required prefix; only topics whose name starts with this string are
    //  *     returned
    //  * @param types array of data type strings
    //  * @return Array of topic information.
    //  */
    // public TopicInfo[] GetTopicInfo(String prefix, String[] types) {
    //   return NtCore.GetTopicInfosStr(this, Handle, prefix, types);
    // }

    // /* Cache of created entries. */
    // private final ConcurrentMap<String, NetworkTableEntry> m_entries = new ConcurrentHashMap<>();

    // /**
    //  * Gets the entry for a key.
    //  *
    //  * @param name Key
    //  * @return Network table entry.
    //  */
    // public NetworkTableEntry GetEntry(String name) {
    //   NetworkTableEntry entry = m_entries.Get(name);
    //   if (entry == null) {
    //     entry = new NetworkTableEntry(this, NtCore.GetEntry(Handle, name));
    //     NetworkTableEntry oldEntry = m_entries.putIfAbsent(name, entry);
    //     if (oldEntry != null) {
    //       entry = oldEntry;
    //     }
    //   }
    //   return entry;
    // }

    // /* Cache of created topics. */
    // private final ConcurrentMap<String, Topic> m_topics = new ConcurrentHashMap<>();
    // private final ConcurrentMap<Integer, Topic> m_topicsByHandle = new ConcurrentHashMap<>();

    // Topic GetCachedTopic(String name) {
    //   Topic topic = m_topics.Get(name);
    //   if (topic == null) {
    //     int handle = NtCore.GetTopic(Handle, name);
    //     topic = new Topic(this, handle);
    //     Topic oldTopic = m_topics.putIfAbsent(name, topic);
    //     if (oldTopic != null) {
    //       topic = oldTopic;
    //     }
    //     // also cache by handle
    //     m_topicsByHandle.putIfAbsent(handle, topic);
    //   }
    //   return topic;
    // }

    // Topic GetCachedTopic(int handle) {
    //   Topic topic = m_topicsByHandle.Get(handle);
    //   if (topic == null) {
    //     topic = new Topic(this, handle);
    //     Topic oldTopic = m_topicsByHandle.putIfAbsent(handle, topic);
    //     if (oldTopic != null) {
    //       topic = oldTopic;
    //     }
    //   }
    //   return topic;
    // }

    // /* Cache of created tables. */
    // private final ConcurrentMap<String, NetworkTable> m_tables = new ConcurrentHashMap<>();

    // /**
    //  * Gets the table with the specified key.
    //  *
    //  * @param key the key name
    //  * @return The network table
    //  */
    // public NetworkTable GetTable(String key) {
    //   // prepend leading / if not present
    //   String theKey;
    //   if (key.isEmpty() || "/".equals(key)) {
    //     theKey = "";
    //   } else if (key.charAt(0) == NetworkTable.PATH_SEPARATOR) {
    //     theKey = key;
    //   } else {
    //     theKey = NetworkTable.PATH_SEPARATOR + key;
    //   }

    //   // cache created tables
    //   NetworkTable table = m_tables.Get(theKey);
    //   if (table == null) {
    //     table = new NetworkTable(this, theKey);
    //     NetworkTable oldTable = m_tables.putIfAbsent(theKey, table);
    //     if (oldTable != null) {
    //       table = oldTable;
    //     }
    //   }
    //   return table;
    // }

    // /*
    //  * Callback Creation Functions
    //  */

    // private static class ListenerStorage implements AutoCloseable {
    //   private final ReentrantLock m_lock = new ReentrantLock();
    //   private final Map<Integer, Consumer<NetworkTableEvent>> m_listeners = new HashMap<>();
    //   private Thread m_thread;
    //   private int m_poller;
    //   private boolean m_waitQueue;
    //   private final Event m_waitQueueEvent = new Event();
    //   private final Condition m_waitQueueCond = m_lock.newCondition();
    //   private final NetworkTableInstance m_inst;

    //   ListenerStorage(NetworkTableInstance inst) {
    //     m_inst = inst;
    //   }

    //   int add(
    //       String[] prefixes,
    //       EnumSet<NetworkTableEvent.Kind> eventKinds,
    //       Consumer<NetworkTableEvent> listener) {
    //     m_lock.lock();
    //     try {
    //       if (m_poller == 0) {
    //         m_poller = NtCore.createListenerPoller(m_inst.GetHandle());
    //         startThread();
    //       }
    //       int h = NtCore.addListener(m_poller, prefixes, eventKinds);
    //       m_listeners.put(h, listener);
    //       return h;
    //     } finally {
    //       m_lock.unlock();
    //     }
    //   }

    //   int add(
    //       int handle,
    //       EnumSet<NetworkTableEvent.Kind> eventKinds,
    //       Consumer<NetworkTableEvent> listener) {
    //     m_lock.lock();
    //     try {
    //       if (m_poller == 0) {
    //         m_poller = NtCore.createListenerPoller(m_inst.GetHandle());
    //         startThread();
    //       }
    //       int h = NtCore.addListener(m_poller, handle, eventKinds);
    //       m_listeners.put(h, listener);
    //       return h;
    //     } finally {
    //       m_lock.unlock();
    //     }
    //   }

    //   int addLogger(int minLevel, int maxLevel, Consumer<NetworkTableEvent> listener) {
    //     m_lock.lock();
    //     try {
    //       if (m_poller == 0) {
    //         m_poller = NtCore.createListenerPoller(m_inst.GetHandle());
    //         startThread();
    //       }
    //       int h = NtCore.addLogger(m_poller, minLevel, maxLevel);
    //       m_listeners.put(h, listener);
    //       return h;
    //     } finally {
    //       m_lock.unlock();
    //     }
    //   }

    //   void remove(int listener) {
    //     m_lock.lock();
    //     try {
    //       m_listeners.remove(listener);
    //     } finally {
    //       m_lock.unlock();
    //     }
    //     NtCore.removeListener(listener);
    //   }


    //   public void close() {
    //     if (m_poller != 0) {
    //       NtCore.destroyListenerPoller(m_poller);
    //     }
    //     m_poller = 0;
    //   }

    //   private void startThread() {
    //     m_thread =
    //         new Thread(
    //             () -> {
    //               boolean wasInterrupted = false;
    //               int[] handles = new int[] { m_poller, m_waitQueueEvent.GetHandle() };
    //               while (!Thread.interrupted()) {
    //                 try {
    //                   WPIUtilJNI.waitForObjects(handles);
    //                 } catch (InterruptedException ex) {
    //                   m_lock.lock();
    //                   try {
    //                     if (m_waitQueue) {
    //                       m_waitQueue = false;
    //                       m_waitQueueCond.signalAll();
    //                     }
    //                   } finally {
    //                     m_lock.unlock();
    //                   }
    //                   Thread.currentThread().interrupt();
    //                   // don't try to destroy poller, as its handle is likely no longer valid
    //                   wasInterrupted = true;
    //                   break;
    //                 }
    //                 for (NetworkTableEvent event :
    //                     NtCore.readListenerQueue(m_inst, m_poller)) {
    //                   Consumer<NetworkTableEvent> listener;
    //                   m_lock.lock();
    //                   try {
    //                     listener = m_listeners.Get(event.listener);
    //                   } finally {
    //                     m_lock.unlock();
    //                   }
    //                   if (listener != null) {
    //                     try {
    //                       listener.accept(event);
    //                     } catch (Throwable throwable) {
    //                       System.err.println(
    //                           "Unhandled exception during listener callback: "
    //                           + throwable.toString());
    //                       throwable.printStackTrace();
    //                     }
    //                   }
    //                 }
    //                 m_lock.lock();
    //                 try {
    //                   if (m_waitQueue) {
    //                     m_waitQueue = false;
    //                     m_waitQueueCond.signalAll();
    //                   }
    //                 } finally {
    //                   m_lock.unlock();
    //                 }
    //               }
    //               m_lock.lock();
    //               try {
    //                 if (!wasInterrupted) {
    //                   NtCore.destroyListenerPoller(m_poller);
    //                 }
    //                 m_poller = 0;
    //               } finally {
    //                 m_lock.unlock();
    //               }
    //             },
    //             "NTListener");
    //     m_thread.setDaemon(true);
    //     m_thread.start();
    //   }

    //   boolean waitForQueue(double timeout) {
    //     m_lock.lock();
    //     try {
    //       if (m_poller != 0) {
    //         m_waitQueue = true;
    //         m_waitQueueEvent.set();
    //         while (m_waitQueue) {
    //           try {
    //             if (timeout < 0) {
    //               m_waitQueueCond.await();
    //             } else {
    //               return m_waitQueueCond.await((long) (timeout * 1e9), TimeUnit.NANOSECONDS);
    //             }
    //           } catch (InterruptedException ex) {
    //             Thread.currentThread().interrupt();
    //             return true;
    //           }
    //         }
    //       }
    //     } finally {
    //       m_lock.unlock();
    //     }
    //     return true;
    //   }
    // }

    // private final ListenerStorage m_listeners = new ListenerStorage(this);

    // /**
    //  * Remove a connection listener.
    //  *
    //  * @param listener Listener handle to remove
    //  */
    // public void removeListener(int listener) {
    //   m_listeners.remove(listener);
    // }

    // /**
    //  * Wait for the listener queue to be empty. This is primarily useful for deterministic
    //  * testing. This blocks until either the listener queue is empty (e.g. there are no
    //  * more events that need to be passed along to callbacks or poll queues) or the timeout expires.
    //  *
    //  * @param timeout timeout, in seconds. Set to 0 for non-blocking behavior, or a negative value to
    //  *     block indefinitely
    //  * @return False if timed out, otherwise true.
    //  */
    // public boolean waitForListenerQueue(double timeout) {
    //   return m_listeners.waitForQueue(timeout);
    // }

    // /**
    //  * Add a connection listener. The callback function is called asynchronously on a separate
    //  * thread, so it's important to use synchronization or atomics when accessing any shared state
    //  * from the callback function.
    //  *
    //  * @param immediateNotify Notify listener of all existing connections
    //  * @param listener Listener to add
    //  * @return Listener handle
    //  */
    // public int addConnectionListener(
    //     boolean immediateNotify, Consumer<NetworkTableEvent> listener) {
    //   EnumSet<NetworkTableEvent.Kind> eventKinds = EnumSet.of(NetworkTableEvent.Kind.kConnection);
    //   if (immediateNotify) {
    //     eventKinds.add(NetworkTableEvent.Kind.kImmediate);
    //   }
    //   return m_listeners.add(Handle, eventKinds, listener);
    // }

    // /**
    //  * Add a time synchronization listener. The callback function is called asynchronously on a
    //  * separate thread, so it's important to use synchronization or atomics when accessing any shared
    //  * state from the callback function.
    //  *
    //  * @param immediateNotify Notify listener of current time synchronization value
    //  * @param listener Listener to add
    //  * @return Listener handle
    //  */
    // public int addTimeSyncListener(
    //     boolean immediateNotify, Consumer<NetworkTableEvent> listener) {
    //   EnumSet<NetworkTableEvent.Kind> eventKinds = EnumSet.of(NetworkTableEvent.Kind.kTimeSync);
    //   if (immediateNotify) {
    //     eventKinds.add(NetworkTableEvent.Kind.kImmediate);
    //   }
    //   return m_listeners.add(Handle, eventKinds, listener);
    // }

    // /**
    //  * Add a listener for changes on a particular topic. The callback function is called
    //  * asynchronously on a separate thread, so it's important to use synchronization or atomics when
    //  * accessing any shared state from the callback function.
    //  *
    //  * <p>This creates a corresponding internal subscriber with the lifetime of the
    //  * listener.
    //  *
    //  * @param topic Topic
    //  * @param eventKinds set of event kinds to listen to
    //  * @param listener Listener function
    //  * @return Listener handle
    //  */
    // public int addListener(
    //     Topic topic,
    //     EnumSet<NetworkTableEvent.Kind> eventKinds,
    //     Consumer<NetworkTableEvent> listener) {
    //   if (topic.GetInstance().GetHandle() != Handle) {
    //     throw new IllegalArgumentException("topic is not from this instance");
    //   }
    //   return m_listeners.add(topic.GetHandle(), eventKinds, listener);
    // }

    // /**
    //  * Add a listener for changes on a subscriber. The callback function is called
    //  * asynchronously on a separate thread, so it's important to use synchronization or atomics when
    //  * accessing any shared state from the callback function. This does NOT keep the subscriber
    //  * active.
    //  *
    //  * @param subscriber Subscriber
    //  * @param eventKinds set of event kinds to listen to
    //  * @param listener Listener function
    //  * @return Listener handle
    //  */
    // public int addListener(
    //     Subscriber subscriber,
    //     EnumSet<NetworkTableEvent.Kind> eventKinds,
    //     Consumer<NetworkTableEvent> listener) {
    //   if (subscriber.GetTopic().GetInstance().GetHandle() != Handle) {
    //     throw new IllegalArgumentException("subscriber is not from this instance");
    //   }
    //   return m_listeners.add(subscriber.GetHandle(), eventKinds, listener);
    // }

    // /**
    //  * Add a listener for changes on a subscriber. The callback function is called
    //  * asynchronously on a separate thread, so it's important to use synchronization or atomics when
    //  * accessing any shared state from the callback function. This does NOT keep the subscriber
    //  * active.
    //  *
    //  * @param subscriber Subscriber
    //  * @param eventKinds set of event kinds to listen to
    //  * @param listener Listener function
    //  * @return Listener handle
    //  */
    // public int addListener(
    //     MultiSubscriber subscriber,
    //     EnumSet<NetworkTableEvent.Kind> eventKinds,
    //     Consumer<NetworkTableEvent> listener) {
    //   if (subscriber.GetInstance().GetHandle() != Handle) {
    //     throw new IllegalArgumentException("subscriber is not from this instance");
    //   }
    //   return m_listeners.add(subscriber.GetHandle(), eventKinds, listener);
    // }

    // /**
    //  * Add a listener for changes on an entry. The callback function is called
    //  * asynchronously on a separate thread, so it's important to use synchronization or atomics when
    //  * accessing any shared state from the callback function.
    //  *
    //  * @param entry Entry
    //  * @param eventKinds set of event kinds to listen to
    //  * @param listener Listener function
    //  * @return Listener handle
    //  */
    // public int addListener(
    //     NetworkTableEntry entry,
    //     EnumSet<NetworkTableEvent.Kind> eventKinds,
    //     Consumer<NetworkTableEvent> listener) {
    //   if (entry.GetTopic().GetInstance().GetHandle() != Handle) {
    //     throw new IllegalArgumentException("entry is not from this instance");
    //   }
    //   return m_listeners.add(entry.GetHandle(), eventKinds, listener);
    // }

    // /**
    //  * Add a listener for changes to topics with names that start with any of the given
    //  * prefixes. The callback function is called asynchronously on a separate thread, so it's
    //  * important to use synchronization or atomics when accessing any shared state from the callback
    //  * function.
    //  *
    //  * <p>This creates a corresponding internal subscriber with the lifetime of the
    //  * listener.
    //  *
    //  * @param prefixes Topic name string prefixes
    //  * @param eventKinds set of event kinds to listen to
    //  * @param listener Listener function
    //  * @return Listener handle
    //  */
    // public int addListener(
    //     String[] prefixes,
    //     EnumSet<NetworkTableEvent.Kind> eventKinds,
    //     Consumer<NetworkTableEvent> listener) {
    //   return m_listeners.add(prefixes, eventKinds, listener);
    // }

    // /*
    //  * Client/Server Functions
    //  */

    // /**
    //  * Get the current network mode.
    //  *
    //  * @return Enum set of NetworkMode.
    //  */
    // public EnumSet<NetworkMode> GetNetworkMode() {
    //   int flags = NtCore.GetNetworkMode(Handle);
    //   EnumSet<NetworkMode> rv = EnumSet.noneOf(NetworkMode.class);
    //   for (NetworkMode mode : NetworkMode.values()) {
    //     if ((flags & mode.GetValue()) != 0) {
    //       rv.add(mode);
    //     }
    //   }
    //   return rv;
    // }

    // /**
    //  * Starts local-only operation. Prevents calls to startServer or startClient from taking effect.
    //  * Has no effect if startServer or startClient has already been called.
    //  */
    // public void startLocal() {
    //   NtCore.startLocal(Handle);
    // }

    // /**
    //  * Stops local-only operation. startServer or startClient can be called after this call to start
    //  * a server or client.
    //  */
    // public void stopLocal() {
    //   NtCore.stopLocal(Handle);
    // }

    // /**
    //  * Starts a server using the networktables.json as the persistent file, using the default
    //  * listening address and port.
    //  */
    // public void startServer() {
    //   startServer("networktables.json");
    // }

    // /**
    //  * Starts a server using the specified persistent filename, using the default listening address
    //  * and port.
    //  *
    //  * @param persistFilename the name of the persist file to use
    //  */
    // public void startServer(String persistFilename) {
    //   startServer(persistFilename, "");
    // }

    // /**
    //  * Starts a server using the specified filename and listening address, using the default port.
    //  *
    //  * @param persistFilename the name of the persist file to use
    //  * @param listenAddress the address to listen on, or empty to listen on any address
    //  */
    // public void startServer(String persistFilename, String listenAddress) {
    //   startServer(persistFilename, listenAddress, kDefaultPort3, kDefaultPort4);
    // }

    // /**
    //  * Starts a server using the specified filename, listening address, and port.
    //  *
    //  * @param persistFilename the name of the persist file to use
    //  * @param listenAddress the address to listen on, or empty to listen on any address
    //  * @param port3 port to communicate over (NT3)
    //  */
    // public void startServer(String persistFilename, String listenAddress, int port3) {
    //   startServer(persistFilename, listenAddress, port3, kDefaultPort4);
    // }

    // /**
    //  * Starts a server using the specified filename, listening address, and port.
    //  *
    //  * @param persistFilename the name of the persist file to use
    //  * @param listenAddress the address to listen on, or empty to listen on any address
    //  * @param port3 port to communicate over (NT3)
    //  * @param port4 port to communicate over (NT4)
    //  */
    // public void startServer(String persistFilename, String listenAddress, int port3, int port4) {
    //   NtCore.startServer(Handle, persistFilename, listenAddress, port3, port4);
    // }

    // /** Stops the server if it is running. */
    // public void stopServer() {
    //   NtCore.stopServer(Handle);
    // }

    // /**
    //  * Starts a NT3 client. Use SetServer or SetServerTeam to set the server name and port.
    //  *
    //  * @param identity network identity to advertise (cannot be empty string)
    //  */
    // public void startClient3(String identity) {
    //   NtCore.startClient3(Handle, identity);
    // }

    // /**
    //  * Starts a NT4 client. Use SetServer or SetServerTeam to set the server name and port.
    //  *
    //  * @param identity network identity to advertise (cannot be empty string)
    //  */
    // public void startClient4(String identity) {
    //   NtCore.startClient4(Handle, identity);
    // }

    // /** Stops the client if it is running. */
    // public void stopClient() {
    //   NtCore.stopClient(Handle);
    // }

    // /**
    //  * Sets server address and port for client (without restarting client). Changes the port to the
    //  * default port.
    //  *
    //  * @param serverName server name
    //  */
    // public void setServer(String serverName) {
    //   setServer(serverName, 0);
    // }

    // /**
    //  * Sets server address and port for client (without restarting client).
    //  *
    //  * @param serverName server name
    //  * @param port port to communicate over (0=default)
    //  */
    // public void setServer(String serverName, int port) {
    //   NtCore.setServer(Handle, serverName, port);
    // }

    // /**
    //  * Sets server addresses and port for client (without restarting client). Changes the port to the
    //  * default port. The client will attempt to connect to each server in round robin fashion.
    //  *
    //  * @param serverNames array of server names
    //  */
    // public void setServer(String[] serverNames) {
    //   setServer(serverNames, 0);
    // }

    // /**
    //  * Sets server addresses and port for client (without restarting client). The client will attempt
    //  * to connect to each server in round robin fashion.
    //  *
    //  * @param serverNames array of server names
    //  * @param port port to communicate over (0=default)
    //  */
    // public void setServer(String[] serverNames, int port) {
    //   int[] ports = new int[serverNames.length];
    //   for (int i = 0; i < serverNames.length; i++) {
    //     ports[i] = port;
    //   }
    //   setServer(serverNames, ports);
    // }

    // /**
    //  * Sets server addresses and ports for client (without restarting client). The client will
    //  * attempt to connect to each server in round robin fashion.
    //  *
    //  * @param serverNames array of server names
    //  * @param ports array of port numbers (0=default)
    //  */
    // public void setServer(String[] serverNames, int[] ports) {
    //   NtCore.setServer(Handle, serverNames, ports);
    // }

    // /**
    //  * Sets server addresses and port for client (without restarting client). Changes the port to the
    //  * default port. The client will attempt to connect to each server in round robin fashion.
    //  *
    //  * @param team team number
    //  */
    // public void setServerTeam(int team) {
    //   setServerTeam(team, 0);
    // }

    // /**
    //  * Sets server addresses and port for client (without restarting client). Connects using commonly
    //  * known robot addresses for the specified team.
    //  *
    //  * @param team team number
    //  * @param port port to communicate over (0=default)
    //  */
    // public void setServerTeam(int team, int port) {
    //   NtCore.setServerTeam(Handle, team, port);
    // }

    // /**
    //  * Disconnects the client if it's running and connected. This will automatically start
    //  * reconnection attempts to the current server list.
    //  */
    // public void disconnect() {
    //   NtCore.disconnect(Handle);
    // }

    // /**
    //  * Starts requesting server address from Driver Station. This connects to the Driver Station
    //  * running on localhost to obtain the server IP address, and connects with the default port.
    //  */
    // public void startDSClient() {
    //   startDSClient(0);
    // }

    // /**
    //  * Starts requesting server address from Driver Station. This connects to the Driver Station
    //  * running on localhost to obtain the server IP address.
    //  *
    //  * @param port server port to use in combination with IP from DS (0=default)
    //  */
    // public void startDSClient(int port) {
    //   NtCore.startDSClient(Handle, port);
    // }

    // /** Stops requesting server address from Driver Station. */
    // public void stopDSClient() {
    //   NtCore.stopDSClient(Handle);
    // }

    // /**
    //  * Flushes all updated values immediately to the local client/server. This does not flush to the
    //  * network.
    //  */
    // public void flushLocal() {
    //   NtCore.flushLocal(Handle);
    // }

    // /**
    //  * Flushes all updated values immediately to the network. Note: This is rate-limited to protect
    //  * the network from flooding. This is primarily useful for synchronizing network updates with
    //  * user code.
    //  */
    // public void flush() {
    //   NtCore.flush(Handle);
    // }

    // /**
    //  * Gets information on the currently established network connections. If operating as a client,
    //  * this will return either zero or one values.
    //  *
    //  * @return array of connection information
    //  */
    // public ConnectionInfo[] GetConnections() {
    //   return NtCore.GetConnections(Handle);
    // }

    // /**
    //  * Return whether or not the instance is connected to another node.
    //  *
    //  * @return True if connected.
    //  */
    // public boolean isConnected() {
    //   return NtCore.isConnected(Handle);
    // }

    // /**
    //  * Get the time offset between server time and local time. Add this value to local time to Get
    //  * the estimated equivalent server time. In server mode, this always returns 0. In client mode,
    //  * this returns the time offset only if the client and server are connected and have exchanged
    //  * synchronization messages. Note the time offset may change over time as it is periodically
    //  * updated; to receive updates as events, add a listener to the "time sync" event.
    //  *
    //  * @return Time offset in microseconds (optional)
    //  */
    // public OptionalLong GetServerTimeOffset() {
    //   return NtCore.GetServerTimeOffset(Handle);
    // }

    // /**
    //  * Starts logging entry changes to a DataLog.
    //  *
    //  * @param log data log object; lifetime must extend until StopEntryDataLog is called or the
    //  *     instance is destroyed
    //  * @param prefix only store entries with names that start with this prefix; the prefix is not
    //  *     included in the data log entry name
    //  * @param logPrefix prefix to add to data log entry names
    //  * @return Data logger handle
    //  */
    // public int startEntryDataLog(DataLog log, String prefix, String logPrefix) {
    //   return NtCore.startEntryDataLog(Handle, log, prefix, logPrefix);
    // }

    // /**
    //  * Stops logging entry changes to a DataLog.
    //  *
    //  * @param logger data logger handle
    //  */
    // public static void stopEntryDataLog(int logger) {
    //   NtCore.stopEntryDataLog(logger);
    // }

    // /**
    //  * Starts logging connection changes to a DataLog.
    //  *
    //  * @param log data log object; lifetime must extend until StopConnectionDataLog is called or the
    //  *     instance is destroyed
    //  * @param name data log entry name
    //  * @return Data logger handle
    //  */
    // public int startConnectionDataLog(DataLog log, String name) {
    //   return NtCore.startConnectionDataLog(Handle, log, name);
    // }

    // /**
    //  * Stops logging connection changes to a DataLog.
    //  *
    //  * @param logger data logger handle
    //  */
    // public static void stopConnectionDataLog(int logger) {
    //   NtCore.stopConnectionDataLog(logger);
    // }

    // /**
    //  * Add logger callback function. By default, log messages are sent to stderr; this function sends
    //  * log messages with the specified levels to the provided callback function instead. The callback
    //  * function will only be called for log messages with level greater than or equal to minLevel and
    //  * less than or equal to maxLevel; messages outside this range will be silently ignored.
    //  *
    //  * @param minLevel minimum log level
    //  * @param maxLevel maximum log level
    //  * @param func callback function
    //  * @return Listener handle
    //  */
    // public int addLogger(int minLevel, int maxLevel, Consumer<NetworkTableEvent> func) {
    //   return m_listeners.addLogger(minLevel, maxLevel, func);
    // }

    // /**
    //  * Returns whether there is a data schema already registered with the given name that this
    //  * instance has published. This does NOT perform a check as to whether the schema has already
    //  * been published by another node on the network.
    //  *
    //  * @param name Name (the string passed as the data type for topics using this schema)
    //  * @return True if schema already registered
    //  */
    // public boolean hasSchema(String name) {
    //   return m_schemas.containsKey("/.schema/" + name);
    // }

    // /**
    //  * Registers a data schema. Data schemas provide information for how a certain data type string
    //  * can be decoded. The type string of a data schema indicates the type of the schema itself (e.g.
    //  * "protobuf" for protobuf schemas, "struct" for struct schemas, etc). In NetworkTables, schemas
    //  * are published just like normal topics, with the name being generated from the provided name:
    //  * "/.schema/name". Duplicate calls to this function with the same name are silently ignored.
    //  *
    //  * @param name Name (the string passed as the data type for topics using this schema)
    //  * @param type Type of schema (e.g. "protobuf", "struct", etc)
    //  * @param schema Schema data
    //  */
    // public void addSchema(String name, String type, byte[] schema) {
    //   m_schemas.computeIfAbsent("/.schema/" + name, k -> {
    //     RawPublisher pub = GetRawTopic(k).publishEx(type, "{\"retained\":true}");
    //     pub.setDefault(schema);
    //     return pub;
    //   });
    // }

    // /**
    //  * Registers a data schema. Data schemas provide information for how a certain data type string
    //  * can be decoded. The type string of a data schema indicates the type of the schema itself (e.g.
    //  * "protobuf" for protobuf schemas, "struct" for struct schemas, etc). In NetworkTables, schemas
    //  * are published just like normal topics, with the name being generated from the provided name:
    //  * "/.schema/name". Duplicate calls to this function with the same name are silently ignored.
    //  *
    //  * @param name Name (the string passed as the data type for topics using this schema)
    //  * @param type Type of schema (e.g. "protobuf", "struct", etc)
    //  * @param schema Schema data
    //  */
    // public void addSchema(String name, String type, String schema) {
    //   m_schemas.computeIfAbsent("/.schema/" + name, k -> {
    //     RawPublisher pub = GetRawTopic(k).publishEx(type, "{\"retained\":true}");
    //     pub.setDefault(StandardCharsets.UTF_8.encode(schema));
    //     return pub;
    //   });
    // }

    // /**
    //  * Registers a protobuf schema. Duplicate calls to this function with the same name are silently
    //  * ignored.
    //  *
    //  * @param proto protobuf serialization object
    //  */
    // public void addSchema(Protobuf<?, ?> proto) {
    //   proto.forEachDescriptor(
    //       this::hasSchema,
    //       (typeString, schema) -> addSchema(typeString, "proto:FileDescriptorProto", schema));
    // }

    // /**
    //  * Registers a struct schema. Duplicate calls to this function with the same name are silently
    //  * ignored.
    //  *
    //  * @param struct struct serialization object
    //  */
    // public void addSchema(Struct<?> struct) {
    //   addSchemaImpl(struct, new HashSet<>());
    // }


    // public bool Equals(object other) {
    //   if (other == this) {
    //     return true;
    //   }
    //   if (!(other instanceof NetworkTableInstance)) {
    //     return false;
    //   }

    //   return Handle == ((NetworkTableInstance) other).Handle;
    // }


    // public override int GetHashCode() {
    //   return Handle;
    // }

    // // TODO Add back in schema impl;

    // private bool m_owned;
    // private final ConcurrentMap<String, RawPublisher> m_schemas = new ConcurrentHashMap<>();
}
